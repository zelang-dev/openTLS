<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   $OpenBSD: tls_read.3,v 1.8 2023/09/18 17:25:15 schwarze Exp $
  
   Copyright (c) 2014, 2015 Ted Unangst <tedu@openbsd.org>
   Copyright (c) 2015 Doug Hogan <doug@openbsd.org>
   Copyright (c) 2015 Joel Sing <jsing@openbsd.org>
   Copyright (c) 2015 Bob Beck <beck@openbsd.org>
   Copyright (c) 2017 Ingo Schwarze <schwarze@openbsd.org>
  
   Permission to use, copy, modify, and distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.
  
   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>TLS_READ(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">TLS_READ(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">TLS_READ(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">tls_read</code>,
    <code class="Nm">tls_write</code>, <code class="Nm">tls_handshake</code>,
    <code class="Nm">tls_error</code>, <code class="Nm">tls_close</code>
    &#x2014; <span class="Nd">use a TLS connection</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
  &lt;<a class="In">tls.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">ssize_t</var>
  <br/>
  <code class="Fn">tls_read</code>(<var class="Fa">struct tls *ctx</var>,
    <var class="Fa">void *buf</var>, <var class="Fa">size_t buflen</var>);</p>
<p class="Pp"><var class="Ft">ssize_t</var>
  <br/>
  <code class="Fn">tls_write</code>(<var class="Fa">struct tls *ctx</var>,
    <var class="Fa">const void *buf</var>, <var class="Fa">size_t
  buflen</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">tls_handshake</code>(<var class="Fa" style="white-space: nowrap;">struct
    tls *ctx</var>);</p>
<p class="Pp"><var class="Ft">const char *</var>
  <br/>
  <code class="Fn">tls_error</code>(<var class="Fa" style="white-space: nowrap;">struct
    tls *ctx</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">tls_close</code>(<var class="Fa" style="white-space: nowrap;">struct
    tls *ctx</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><a class="permalink" href="#tls_read"><code class="Fn" id="tls_read">tls_read</code></a>()
    reads <var class="Fa">buflen</var> bytes of data from the socket into
    <var class="Fa">buf</var>. It returns the amount of data read.</p>
<p class="Pp" id="tls_write"><a class="permalink" href="#tls_write"><code class="Fn">tls_write</code></a>()
    writes <var class="Fa">buflen</var> bytes of data from
    <var class="Fa">buf</var> to the socket. It returns the amount of data
    written.</p>
<p class="Pp" id="tls_handshake"><a class="permalink" href="#tls_handshake"><code class="Fn">tls_handshake</code></a>()
    explicitly performs the TLS handshake. It is only necessary to call this
    function if you need to guarantee that the handshake has completed, as both
    <code class="Fn">tls_read</code>() and <code class="Fn">tls_write</code>()
    automatically perform the TLS handshake when necessary.</p>
<p class="Pp" id="tls_error">The
    <a class="permalink" href="#tls_error"><code class="Fn">tls_error</code></a>()
    function may be used to retrieve a string containing more information about
    the most recent error relating to a context.</p>
<p class="Pp" id="tls_close"><a class="permalink" href="#tls_close"><code class="Fn">tls_close</code></a>()
    closes a connection after use. Only the TLS layer will be shut down and the
    caller is responsible for closing the file descriptors, unless the
    connection was established using <a class="Xr">tls_connect(3)</a> or
    <a class="Xr">tls_connect_servername(3)</a>. After closing the connection,
    <var class="Fa">ctx</var> can be passed to
  <a class="Xr">tls_free(3)</a>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp"><code class="Fn">tls_read</code>() and
    <code class="Fn">tls_write</code>() return a size on success or -1 on
  error.</p>
<p class="Pp"><code class="Fn">tls_handshake</code>() and
    <code class="Fn">tls_close</code>() return 0 on success or -1 on error.</p>
<p class="Pp">The <code class="Fn">tls_read</code>(),
    <code class="Fn">tls_write</code>(),
    <code class="Fn">tls_handshake</code>(), and
    <code class="Fn">tls_close</code>() functions also have two special return
    values:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<dl class="Bl-tag Bl-compact">
  <dt id="TLS_WANT_POLLIN"><a class="permalink" href="#TLS_WANT_POLLIN"><code class="Dv">TLS_WANT_POLLIN</code></a></dt>
  <dd>The underlying read file descriptor needs to be readable in order to
      continue.</dd>
  <dt id="TLS_WANT_POLLOUT"><a class="permalink" href="#TLS_WANT_POLLOUT"><code class="Dv">TLS_WANT_POLLOUT</code></a></dt>
  <dd>The underlying write file descriptor needs to be writeable in order to
      continue.</dd>
</dl>
</div>
<p class="Pp">In the case of blocking file descriptors, the same function call
    should be repeated immediately. In the case of non-blocking file
    descriptors, the same function call should be repeated when the required
    condition has been met.</p>
<p class="Pp">Callers of these functions cannot rely on the value of the global
    <var class="Ar">errno</var>. To prevent mishandling of error conditions,
    <code class="Fn">tls_read</code>(), <code class="Fn">tls_write</code>(),
    <code class="Fn">tls_handshake</code>(), and
    <code class="Fn">tls_close</code>() all explicitly clear
    <var class="Ar">errno</var>.</p>
<p class="Pp"><code class="Fn">tls_error</code>() returns
    <code class="Dv">NULL</code> if no error occurred with
    <var class="Fa">ctx</var> during or since the last call to
    <code class="Fn">tls_handshake</code>(), <code class="Fn">tls_read</code>(),
    <code class="Fn">tls_write</code>(), <code class="Fn">tls_close</code>(), or
    <a class="Xr">tls_reset(3)</a> involving <var class="Fa">ctx</var>, or if
    memory allocation failed while trying to assemble the string describing the
    most recent error related to <var class="Fa">ctx</var>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The following example demonstrates how to handle TLS writes on a
    blocking file descriptor:</p>
<div class="Bd Pp Bd-indent Li">
<pre>...
while (len &gt; 0) {
	ssize_t ret;

	ret = tls_write(ctx, buf, len);
	if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT)
		continue;
	if (ret == -1)
		errx(1, &quot;tls_write: %s&quot;, tls_error(ctx));
	buf += ret;
	len -= ret;
}
...</pre>
</div>
<p class="Pp">The following example demonstrates how to handle TLS writes on a
    non-blocking file descriptor using <a class="Xr">poll(2)</a>:</p>
<div class="Bd Pp Bd-indent Li">
<pre>...
pfd[0].fd = fd;
pfd[0].events = POLLIN|POLLOUT;
while (len &gt; 0) {
	nready = poll(pfd, 1, 0);
	if (nready == -1)
		err(1, &quot;poll&quot;);
	if ((pfd[0].revents &amp; (POLLERR|POLLNVAL)))
		errx(1, &quot;bad fd %d&quot;, pfd[0].fd);
	if ((pfd[0].revents &amp; (pfd[0].events|POLLHUP))) {
		ssize_t ret;

		ret = tls_write(ctx, buf, len);
		if (ret == TLS_WANT_POLLIN)
			pfd[0].events = POLLIN;
		else if (ret == TLS_WANT_POLLOUT)
			pfd[0].events = POLLOUT;
		else if (ret == -1)
			errx(1, &quot;tls_write: %s&quot;, tls_error(ctx));
		else {
			buf += ret;
			len -= ret;
		}
	}
}
...</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr">tls_accept_socket(3)</a>,
    <a class="Xr">tls_configure(3)</a>, <a class="Xr">tls_conn_version(3)</a>,
    <a class="Xr">tls_connect(3)</a>, <a class="Xr">tls_init(3)</a>,
    <a class="Xr">tls_ocsp_process_response(3)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp"><code class="Fn">tls_read</code>(),
    <code class="Fn">tls_write</code>(), <code class="Fn">tls_error</code>(),
    and <code class="Fn">tls_close</code>() appeared in <span class="Ux">OpenBSD
    5.6</span> and got their final names in <span class="Ux">OpenBSD
  5.7</span>.</p>
<p class="Pp"><code class="Fn">tls_handshake</code>() appeared in
    <span class="Ux">OpenBSD 5.9</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp"><span class="An">Joel Sing</span>
    &lt;<a class="Mt" href="mailto:jsing@openbsd.org">jsing@openbsd.org</a>&gt;
    with contributions from
  <br/>
  <span class="An">Bob Beck</span>
    &lt;<a class="Mt" href="mailto:beck@openbsd.org">beck@openbsd.org</a>&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">The function <code class="Fn">tls_error</code>() returns an
    internal pointer. It must not be freed by the application, or a double free
    error will occur. The pointer will become invalid when the next error occurs
    with <var class="Fa">ctx</var>. Consequently, if the application may need
    the message at a later time, it has to copy the string before calling the
    next
    <a class="permalink" href="#libtls"><b class="Sy" id="libtls">libtls</b></a>
    function involving <var class="Fa">ctx</var>, or a segmentation fault or
    read access to unintended data is the likely result.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">September 18, 2023</td>
    <td class="foot-os">Debian</td>
  </tr>
</table>
</body>
</html>
